<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
    <title>the gnarly tyke</title>
    <link rel="stylesheet" href="stylesheets/default.css">
</head>
<body>
  <script src="./common.js"></script>
  <h1>the gnarly tyke</h1>
  <div>
    <h2>Baildon Bank</h2>
  </div>
  <div style="margin-top: 2%;">
    <canvas style="margin: auto; display: block" id="select-topo-canvas"></canvas>
    <canvas style="margin: auto; display: block" id="main-topo-canvas"></canvas>
  </div>
  <div style="margin-top: 2%;">
    <table id="route-table" style="margin: auto">
      <thead>
          <tr>
            <th></th>
            <th>Name</th>
            <th>Type</th>
            <th>Grade</th>
          </tr>
      </thead>
      <tbody id="route-table-body">
        <script>
          let UpdateRouteTable = (topo) => {
            document.getElementById('route-table-body').innerHTML = GetRouteTableHTML(topo);
          }
          let GetRouteTableHTML = (topo) => {
            let rowHTML = '';
            GetRoutesForTopo(topo).forEach((route, index) => {
              rowHTML += 
              `<tr>
                <td>${index+1}</td>
                <td>${route.name}</td>
                <td>${route.type}</td>
                <td>${route.grade}</td>
              </tr>
              `;
            });
            return rowHTML;
          }
          let GetRoutesForTopo = topo => {
            if( !topo.routes ) return [];
            return topo.routes.map(route => {
              const routeInfo = _crag.routes[route.globalIndex];
              return {
                name: routeInfo.name,
                type: routeInfo.type,
                grade: routeInfo.grade,
                label: route.label,
                points: route.points
              };
            });
          }
        </script>
      </tbody>
    </table>
  </div>
  <script>
    let _crag = null;
    let _selectedTopoId = null;
    let _lastRenderedTopos = null;
    window.onload = function() {
      LoadCrag("./data/baildon_bank.json")
      .then( crag => {
        _crag = crag;
        _selectedTopoId = _crag.topos[0].id;
        DrawPage(_crag);
        AddMouseSupport(_crag);
      });
    }
    window.onresize = () => {
      if( _crag ) DrawPage(_crag);
    }
    let DrawPage = (crag) => {
      let canvas = document.getElementById("select-topo-canvas");
      _lastRenderedTopos = DrawTopoSelection(canvas, crag.topos);
      if( _selectedTopoId != null ) {
        const matchedTopos = _lastRenderedTopos.filter( topo => topo.id == _selectedTopoId );
        const selectedTopo = ( matchedTopos.length > 0 ) ? matchedTopos[0] : null;
        DrawTopoBox(canvas, selectedTopo, 8, '#000000');
        let mainTopoCanvas = document.getElementById("main-topo-canvas");
        const topo = {};
        Object.assign(topo, selectedTopo);
        DrawMainTopoCanvas(mainTopoCanvas, topo);
        UpdateRouteTable(topo);
      }
    }
    let DrawTopoSelection = (canvas, topoData) => {
      canvas.width = document.documentElement.clientWidth;
      canvas.height = 100;
      const topos = GetRenderData(canvas, topoData, 0.8, 20);
      RenderTopos(canvas, topos);
      return topos;
    }
    let DrawMainTopoCanvas = (canvas, topo) => {
      canvas.width = document.documentElement.clientWidth;
      canvas.height = 400;
      topo.x = 0;
      topo.y = 0;
      let topos = [topo];
      AddImageSizes(topos, canvas, 1.0);
      CentreImagesOnCanvas(topos, canvas);
      RenderTopos(canvas, topos);
      DrawTopoRoutes(canvas, topos[0]);
    }
    let AddMouseSupport = (crag) => {
      let canvas = document.getElementById("select-topo-canvas");
      canvas.onmousemove = event => {
        let currentSelectedTopoId = null;
        _lastRenderedTopos.forEach( topo => {
          var rect = canvas.getBoundingClientRect();
          const mouseX = event.clientX - rect.left;
          const mouseY = event.clientY - rect.top;
          if ( mouseX >= topo.x && mouseX < (topo.x + topo.width) && mouseY >= topo.y && mouseY < (topo.y + topo.height) ) {
            currentSelectedTopoId = topo.id;
          }
        });
        if( currentSelectedTopoId != null && currentSelectedTopoId != _selectedTopoId ) {
          _selectedTopoId = currentSelectedTopoId;
          DrawPage(crag);
        }
      }
    }
    let RenderTopos = (canvas, topos) => {
      topos.forEach( topo => DrawTopoImage(canvas, topo) );
    }
    let DrawTopoImage = (canvas, topo) => {
      let ctx = canvas.getContext("2d");
      ctx.drawImage(topo.image, topo.x, topo.y, topo.width, topo.height);
    }
    let DrawTopoRoutes = (canvas, topo) => {
      const transformedRoutes = TransformRoutes(topo);
      let ctx = canvas.getContext("2d");
      transformedRoutes.forEach( route => {
        if( route.points.start && route.points.end ) DrawLine(ctx, route.points, topo.height * 0.01);
      });
      const labels = transformedRoutes.map( route => { return { value: route.label, pos: route.points.start } });
      labels.forEach( label => DrawLabel(ctx, label, topo.height * 0.02) );
    }
    let DrawTopoBox = (canvas, topo, width, color) => {
      var ctx = canvas.getContext("2d");
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      const halfWidth = width / 2;
      ctx.rect(topo.x - halfWidth, topo.y - halfWidth, topo.width + width, topo.height + width);
      ctx.stroke();
    }
    let GetRenderData = (canvas, topos, scale, space) => {
      let renderTopos = topos.map( topo => {
        const topoCopy = {};
        return Object.assign(topoCopy, topo);
      });
      AddImageSizes(renderTopos, canvas, scale);
      AddImagePositions(renderTopos, canvas);
      AddSpaceBetweenImages(renderTopos, space);
      CentreImagesOnCanvas(renderTopos, canvas);
      return renderTopos;
    }
    let AddImageSizes = (topos, canvas, heightScale) => {
      topos.forEach( topo => {
        topo.height = canvas.height * heightScale;
        topo.width = topo.image.width * topo.height / topo.image.height;
      });
    }
    let AddImagePositions = (topos, canvas) => {
      let position = 0;
      topos.forEach( topo => {
        const thisPosition = position;
        position += topo.width;
        topo.x = thisPosition;
        topo.y = (canvas.height - topo.height) / 2;
      });
    }
    let AddSpaceBetweenImages = (topos, space) => {
      let shift = 0;
      topos.forEach( topo => {
        const thisShift = shift;
        shift += space;
        topo.x += thisShift;
      });
    }
    let CentreImagesOnCanvas = (topos, canvas) => {
      const lastTopo = topos[topos.length - 1];
      let totalImageBoundX = lastTopo.x + lastTopo.width;
      let centreShiftX = ( canvas.width - totalImageBoundX ) / 2;
      topos.forEach( topo => topo.x += centreShiftX );
    }
    let TransformRoutes = (topo) => {
      if( !topo.routes ) return [];
      const routesToRender = topo.routes.filter(route => route.label && route.points && route.points.start);
      return routesToRender.map(route => {
        const tmpRoute = {
          label: route.label,
          points: { 
            start: { x: route.points.start.x * topo.width + topo.x, y: route.points.start.y * topo.height + topo.y}
          }
        }
        tmpRoute.points.end = route.points.end ? { x: route.points.end.x * topo.width + topo.x, y: route.points.end.y * topo.height + topo.y} : null;
        return tmpRoute;
      });
    }
    let DrawLine = (ctx, line, lineWidth) => {
      const lineDash = lineWidth;
      ctx.strokeStyle = 'white';
      ctx.beginPath();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = '#FFFFFF';
      ctx.setLineDash([]);
      ctx.moveTo(line.start.x, line.start.y);
      ctx.lineTo(line.end.x, line.end.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = '#ad1522';
      ctx.setLineDash([lineDash * 2, lineDash]);
      ctx.moveTo(line.start.x, line.start.y);
      ctx.lineTo(line.end.x, line.end.y);
      ctx.stroke();
    }
    let DrawLabel = (ctx, label, size) => {
      const fontSize = size * 2;
      ctx.beginPath();
      ctx.setLineDash([]);
      ctx.arc(label.pos.x, label.pos.y, size, 0, 2 * Math.PI, false);
      ctx.fillStyle = "#FFFFFF";
      ctx.fill();
      ctx.beginPath();
      ctx.arc(label.pos.x, label.pos.y, size, 0, 2 * Math.PI, false);
      ctx.lineWidth = size * 0.1;
      ctx.strokeStyle = "#000000";
      ctx.stroke();
      ctx.font = `bold ${fontSize}px serif`;
      ctx.fillStyle = "#000000";
      ctx.fillText(label.value, label.pos.x - (size * 0.5), label.pos.y + (size * 0.75));
    }
    </script>
</body>
</html>
