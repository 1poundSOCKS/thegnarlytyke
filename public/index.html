<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
    <title>the gnarly tyke</title>
    <link rel="stylesheet" href="stylesheets/default.css">
</head>
<body>
  <script>
    const routes = 
    [
    { "name": "Conch", "type": "Trad", "grade": "HS 4b" },
    { "name": "Scar Wall", "type": "Trad", "grade": "E5 6b" },
    { "name": "Scar", "type": "Trad", "grade": "E2 5b" },
    { "name": "The Flakes", "type": "Trad", "grade": "E3 5c" },
    { "name": "Intrepid", "type": "Trad", "grade": "E6 6a" }
    ];
    const topos =
    [
    {
      "id": 0,
      "imageFile": "./images/conch-area-resize.jpg",
      "routes": [ 
      { "globalIndex": 0, "label": 1, "points": { "start": { "x": 0.42, "y": 0.85 }, "end": { "x": 0.6, "y": 0.15 } } }
      ]
    },
    {
      "id": 1,
      "imageFile": "./images/scar-wall-resize.jpg",
      "routes": [
      { "globalIndex": 1, "label": 1, "points": { "start": { "x": 0.30, "y": 0.80 }, "end": { "x": 0.34, "y": 0.15 } } },
      { "globalIndex": 2, "label": 2, "points": { "start": { "x": 0.44, "y": 0.80 }, "end": { "x": 0.48, "y": 0.12 } } },
      { "globalIndex": 3, "label": 3, "points": { "start": { "x": 0.56, "y": 0.80 }, "end": { "x": 0.55, "y": 0.12 } } },
      { "globalIndex": 4, "label": 4, "points": { "start": { "x": 0.62, "y": 0.82 }, "end": { "x": 0.62, "y": 0.15 } } }
      ]
    }
    ];
    let selectedTopo = null;
    let GetRoutesForSelectedTopo = () => {
      return selectedTopo ? GetRoutesForTopo(selectedTopo) : [];
    }
    let GetRoutesForTopo = topo => {
      return topo.routes.map(route => {
        const routeInfo = routes[route.globalIndex];
        return {
          name: routeInfo.name,
          type: routeInfo.type,
          grade: routeInfo.grade,
          label: route.label,
          points: route.points
        };
      });
    }
    let GetTopoById = (topos, id) => {
      const matchedTopos = topos.filter( topo => topo.id == id );
      return ( matchedTopos.length > 0 ) ? matchedTopos[0] : null;
    }
  </script>
  <h1 class="main-header">the gnarly tyke</h1>
  <div>
    <h2 class="area-name">Baildon Bank</h2>
  </div>
  <div style="margin-top: 2%;">
    <canvas style="margin: auto; display: block" id="topo-canvas"></canvas>
  </div>
  <div style="margin-top: 2%;">
    <table class="route-table" id="route-table" style="margin: auto">
      <thead>
          <tr>
            <th></th>
            <th>Name</th>
            <th>Type</th>
            <th>Grade</th>
          </tr>
      </thead>
      <tbody id="route-table-body">
        <script>
          let GetRouteTableHTML = () => {
            let rowHTML = '';
            GetRoutesForSelectedTopo().forEach((route, index) => {
              rowHTML += 
              `<tr>
                <td>${index+1}</td>
                <td>${route.name}</td>
                <td>${route.type}</td>
                <td>${route.grade}</td>
              </tr>
              `;
            });
            return rowHTML;
            let UpdateRouteTable = () => {
            GetRoutesForSelectedTopo().forEach((route, index) => {
              document.write(GetRouteTableHTML());
            });
          }
          }
        </script>
      </tbody>
    </table>
  </div>
  <script>
    let lastRenderedTopos = null;
    window.onload = function() {
      let loaders = topos.map(topo => LoadImage(topo.imageFile));
      Promise.all(loaders).then(images => {
        workingTopoData = topos.map( (topo, index) => {
          return { id: topo.id, image: images[index], routes: topo.routes };
        });
        DrawPage();
      });
    }
    window.onresize = () => {
      DrawPage();
    }
    let DrawPage = () => {
      RemoveMouseSupport();
      let canvas = document.getElementById("topo-canvas");
      lastRenderedTopos = DrawCanvas(workingTopoData);
      selectedTopo = selectedTopo ? GetTopoById(lastRenderedTopos, selectedTopo.id) : lastRenderedTopos[0];
      DrawImageBox(canvas, selectedTopo, 8, '#000000');
      document.getElementById('route-table-body').innerHTML = GetRouteTableHTML();
      AddMouseSupport();
    }
    let DrawCanvas = (topoData) => {
      let canvas = document.getElementById("topo-canvas");
      canvas.width = document.documentElement.clientWidth;
      canvas.height = document.documentElement.clientHeight * 0.5;
      const images = GetRenderData(canvas, topoData, 0.8, 20);
      RenderImages(canvas, images);
      return images;
    }
    let AddMouseSupport = () => {
      let canvas = document.getElementById("topo-canvas");
      canvas.onmousemove = event => {
        let currentSelectedTopo = null;
        lastRenderedTopos.forEach( topo => {
          var rect = canvas.getBoundingClientRect();
          const mouseX = event.clientX - rect.left;
          const mouseY = event.clientY - rect.top;
          if ( mouseX >= topo.x && mouseX < (topo.x + topo.width) && mouseY >= topo.y && mouseY < (topo.y + topo.height) ) {
            currentSelectedTopo = topo;
          }
        });
        selectedTopo = currentSelectedTopo ? currentSelectedTopo : selectedTopo;
        lastRenderedTopos.forEach( topo => {
          if( topo == selectedTopo ) {
            DrawImageBox(canvas, selectedTopo, 8, '#000000');
            document.getElementById('route-table-body').innerHTML = GetRouteTableHTML();
          }
          else {
            DrawImageBox(canvas, topo, 10, '#FFFFFF');
          }
        });
      }
    }
    let RemoveMouseSupport = () => {
      let canvas = document.getElementById("topo-canvas");
      canvas.onmousemove = null;
    }
    let RenderImages = (canvas, images) => {
      images.forEach( image => DrawTopoImage(canvas, image) );
    }
    let DrawTopoImage = (canvas, image) => {
      let ctx = canvas.getContext("2d");
      ctx.drawImage(image.image, image.x, image.y, image.width, image.height);
      const transformedRoutes = TransformRoutes(image.routes, image.width, image.height, image.x, image.y);
      transformedRoutes.forEach( route => DrawLine(ctx, route.points, image.height * 0.01) );
      const labels = transformedRoutes.map( route => { return { value: route.label, pos: route.points.start } });
      labels.forEach( label => DrawLabel(ctx, label, image.height * 0.02) );
    }
    let DrawImageBox = (canvas, image, width, color) => {
      var ctx = canvas.getContext("2d");
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      const halfWidth = width / 2;
      ctx.rect(image.x - halfWidth, image.y - halfWidth, image.width + width, image.height + width);
      ctx.stroke();
    }
    let LoadImage = (url) => new Promise( (resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = (err) => reject(err);
      img.src = url;
    });
    let GetRenderData = (canvas, topos, scale, space) => {
      topos = AddImageSizes(topos, canvas, scale);
      topos = AddImagePositions(topos, canvas);
      topos = AddSpaceBetweenImages(topos, space);
      return CentreImagesOnCanvas(topos, canvas);
    }
    let GetImageScales = (canvas, images, imageHeightScale) => {
      return images.map(image => canvas.height / image.height * imageHeightScale);
    }
    let AddImageSizes = (topos, canvas, heightScale) => {
      return topos.map( topo => {
        const imageHeight = canvas.height * heightScale;
        const widthScale = imageHeight / topo.image.height;
        return {
          id: topo.id,
          image: topo.image,
          width: topo.image.width * widthScale,
          height: imageHeight,
          routes: topo.routes
        };
      });
    }
    let AddImagePositions = (topos, canvas) => {
      let position = 0;
      return topos.map( topo => {
        const thisPosition = position;
        position += topo.width;
        return {
          id: topo.id,
          image: topo.image,
          width: topo.width,
          height: topo.height,
          routes: topo.routes,
          x: thisPosition,
          y: (canvas.height - topo.height) / 2
        };
      });
    }
    let AddSpaceBetweenImages = (topos, space) => {
      let shift = 0;
      return topos.map( topo => {
        const thisShift = shift;
        shift += space;
        return {
          id: topo.id,
          image: topo.image,
          width: topo.width,
          height: topo.height,
          routes: topo.routes,
          x: topo.x + thisShift,
          y: topo.y
        };
      });
    }
    let CentreImagesOnCanvas = (topos, canvas) => {
      const lastImage = topos[topos.length - 1];
      let totalImageBoundX = lastImage.x + lastImage.width;
      let centreShiftX = ( canvas.width - totalImageBoundX ) / 2;
      return topos.map( topo => {
        return {
          id: topo.id,
          image: topo.image,
          width: topo.width,
          height: topo.height,
          routes: topo.routes,
          x: topo.x + centreShiftX,
          y: topo.y
        };
      });
    }
    let TransformRoutes = (routes, width, imageHeight, x, y) => {
      return routes.map(route => {
        return {
          label: route.label, points: { 
            start: { x: route.points.start.x * width + x, y: route.points.start.y * imageHeight + y}, 
            end: { x: route.points.end.x * width + x, y: route.points.end.y * imageHeight + y}
          }
        };
      });
    }
    let DrawLine = (ctx, line, lineWidth) => {
      const lineDash = lineWidth;
      ctx.strokeStyle = 'white';
      ctx.beginPath();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = '#FFFFFF';
      ctx.setLineDash([]);
      ctx.moveTo(line.start.x, line.start.y);
      ctx.lineTo(line.end.x, line.end.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = '#ad1522';
      ctx.setLineDash([lineDash * 2, lineDash]);
      ctx.moveTo(line.start.x, line.start.y);
      ctx.lineTo(line.end.x, line.end.y);
      ctx.stroke();
    }
    let DrawLabel = (ctx, label, size) => {
      const fontSize = size * 2;
      ctx.beginPath();
      ctx.setLineDash([]);
      ctx.arc(label.pos.x, label.pos.y, size, 0, 2 * Math.PI, false);
      ctx.fillStyle = "#FFFFFF";
      ctx.fill();
      ctx.beginPath();
      ctx.arc(label.pos.x, label.pos.y, size, 0, 2 * Math.PI, false);
      ctx.lineWidth = size * 0.1;
      ctx.strokeStyle = "#000000";
      ctx.stroke();
      ctx.font = `bold ${fontSize}px serif`;
      ctx.fillStyle = "#000000";
      ctx.fillText(label.value, label.pos.x - (size * 0.5), label.pos.y + (size * 0.75));
    }
    </script>
</body>
</html>
